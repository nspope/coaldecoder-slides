---
title: "Inferring complex demographic histories from ARG-derived coalescence time distributions"
author: "Nate Pope"
affiliation: "University of Oregon"
email: "natep@uoregon.edu"
venue: "PhyloSeminar"
date: "12 Nov 2024"
date-format: "MMM D, YYYY"
format: 
  revealjs:
    html-math-method: mathjax
    theme: white
    template-partials:
      - title-slide.html
---

## Demographic inference

::: {.r-stack}

![](fig/pop-model/pop-model-0.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=0}

![](fig/pop-model/pop-model-1.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=1}

![](fig/pop-model/pop-model-2.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=2}

![](fig/pop-model/pop-model-3.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=3}

![](fig/pop-model/intgr-anim-0.gif){.fragment width="50%" fig-align="center" fragment-index=4}

:::

::: {.r-stack} 

::: {.fragment .current-visible fragment-index=0}
Given some population model, $\Theta$
:::

::: {.fragment .current-visible fragment-index=1}
$P(\mathrm{genealogy} \mid \Theta)$
:::

::: {.fragment .current-visible fragment-index=2}
Given some contemporary variation, $y$
:::

::: {.fragment .current-visible fragment-index=3}
$p(y \mid \mathrm{genealogy})$
:::

::: {.fragment .current-visible fragment-index=4}
$p(y \mid \Theta) = \int p(y \mid \mathrm{genealogy}) dP(\mathrm{genealogy} \mid \Theta)$
:::

::: {.fragment .current-visible fragment-index=5}
Inference $\implies \mathrm{argmax}_{\Theta}~p(y \mid \Theta)$
:::

:::

::: {.notes}

- In a nutshell

:::


## Ancestral recombination graphs

::: {.r-stack}

![](fig/arg-3d/arg-3d-0.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-1.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-2.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-3.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-4.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-5.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-6.png){.fragment .current-visible}

![](fig/arg-3d/node-view-0.png){.fragment .current-visible}

![](fig/arg-3d/node-view-1.png){.fragment .current-visible}

![](fig/arg-3d/node-view-2.png){.fragment .current-visible}

:::

::: aside

[Wong et al (2024) *Genetics*; Nielsen et al (2024) *Nat Rev Genet*; Lewanski et al (2024) *PLoS Genet*]{style="font-size: 75%"}

:::

::: {.notes}

- Haplotypes along recombinant sequence of length L

- Single point on sequence, gives genealogy

- Recombination event results in prune/regraft of leaf

- Recombination event results in prune/regraft of root

- Crucial point is, nodes are shared across trees, e.g. ancestral haplotypes

- TODO: haplotype view of ARG? text needed?

- Takeaway, space of ARGs is huge, integrating over it is hard

:::


## Inference at genomic scale

::: {.incremental .fragment}

- Reduce to single diploid and integrate ARG (PSMC, etc.)

- Fit "marginal" sample statistics (SFS, LD, etc.)

- Jointly infer ARG and demography (MCMC)

- [Condition on inferred ARG and ... ?]{style="color:firebrick"}

    - [Speidel et al 2019, 2021 (relate)]{style="color:firebrick"}

    - [Fan et al 2023 (gLike)]{style="color:firebrick"}

    - [Pope et al 2023 (this talk)]{style="color:firebrick"}

:::


## This talk

::: {.r-stack}

![](fig/roadmap/roadmap-0.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=0}

![](fig/roadmap/roadmap-1.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=1}

![](fig/roadmap/roadmap-2.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=2}

:::

::: {.r-stack} 

::: {.fragment .current-visible fragment-index=0}
Get empirical time-to-event distribution from ARG
:::

::: {.fragment .current-visible fragment-index=1}
Reweight events to generate distinct (marginal) distributions
:::

::: {.fragment .current-visible fragment-index=2}
Find model that matches these marginal distributions
:::

:::


## Coalescence time distributions

::: {.r-stack}

![](fig/tree-ecdf/tree-0.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-1.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-0.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-1p.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-1.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-2.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-3.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-4.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-5.png){.fragment .current-visible}

:::


## Marginalizing over trees

::: {.r-stack}

![](fig/marg-ecdf/marg-ecdf-0.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-1.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-2.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-3.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-4.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-5.png){.fragment .current-visible}

:::

::: {.notes}

- Information is sparse in a single tree, especially deep in time, hence we use the ARG.

- The ECDF is a deterministic function of a tree. Integrating over trees gives the true CDF.

- The empirical version sums over trees, weighting by relative span.

- The weighted average converges to true CDF asymptotically

- convergence (?)

:::


## Efficient marginalization

::: {.r-stack}

![](fig/incr-algo/two-trees-0.png){.fragment .current-visible}

![](fig/incr-algo/two-trees-1.png){.fragment .current-visible}

![](fig/incr-algo/two-trees-2.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-0.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-1.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-2.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-3.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-4.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-5.png){.fragment .current-visible}

![](fig/incr-algo/right-tree-detail-0.png){.fragment .current-visible}

![](fig/incr-algo/scaling-0.png){.fragment .current-visible width="60%" fig-align="center"}

:::

::: {.notes}

- Need to leverage redundancy of trees for efficiency

- Work with the TreeSequence data format, tskit library

- Crucial ingredient are "edge differences" between adjacent trees

- e.g. a prune-regraft of a single branch leaves the bulk of the topology unchanged

- The idea is to propagate changes in node state up from the removed/added edge

- If there are multiple edges removed/added, need to be careful about order

- Complexity is O(edges log tips) to get node weights, querying ECDF is binary search O(log nodes)

:::


## Duality of pair coalescence and Ne

::: {.r-stack}

![](fig/ne-duality/size-to-coal-0.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-1.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-2.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-3.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-4.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-5.png){.fragment .current-visible}

:::


## Duality of pair coalescence and Ne

::: {.fragment}
Let $c_{ab} = \frac{\int_a^b c(t) dt}{b - a}$ be average rate over interval,
:::

::: {.r-stack}

::: {.fragment .current-visible}
$$
  1 - \exp\{ -(b - a) c_{ab} \} = \frac{\mathrm{CDF}(b) - \mathrm{CDF}(a)}{1 - \mathrm{CDF}(a)} 
$$
:::

::: {.fragment .current-visible}
$$
  1 - \exp\{ -(b - a) c_{ab} \} \approx \frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)}
$$
:::

::: {.fragment .current-visible}
$$
  c_{ab} \approx (a - b)^{-1} \log \left\{ 1 - \frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)} \right\}
$$
:::

::: {.fragment}
$$
  c_{ab} \approx (b - a)^{-1} \left(\frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)} \right)
$$
:::

:::

::: {.fragment}
Note $c_{ab}^{-1}$ is harmonic average of $n(t)$ over interval
:::


## Duality of pair coalescence and Ne


::: {.r-stack}

![](fig/ne-duality/size-to-coal-6.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-7.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-8.png){.fragment .current-visible}

:::

::: {.notes}

- Ne from coalescence rates from ARG isn't a new idea, cite Relate and maybe Yun's paper. Though maybe estimators are different

:::


## Pair coalescence and structure

Let $u(t)$ be population occupancy at time $t$, e.g.

$$
  u(0) = \{a, b\}
$$

in the present day.


## Pair coalescence and structure

Co-occupancy probability for population $i$ is,

$$
  f_{i,ab}(t) = P(u_t = \{i, i\} \mid u_0 = \{a, b\})
$$

given initial locations.


## Pair coalescence and structure

Thus instantaneous "cross-coalescence" rate,

$$
  c_{ab}(t) = \sum_i f_{i,ab}(t) n_i(t)^{-1}
$$

summing over populations with haploid size $n_i(t)$.


## Pair coalescence and structure

Modelled as an absorbing Markov process,

::: {.incremental}

- $(\#\mathrm{populations})^2$ transitory states 

- Absorbing state is coalescence

- Demographic parameters $\rightarrow$ transition rates

:::


## Pair coalescence and structure

::: {.r-stack}

![](fig/pair-rates/pair-rates-0.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-1.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-2.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-3.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-4.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-5.png){.fragment .current-visible}

![](fig/pair-rates/smooth-anim-0.gif){.fragment .current-visible}

:::

## Inverse problem

::: {.r-stack}

![](fig/pair-rates/pair-optim-0.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-1.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-2.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-3.png){.fragment .current-visible}

![](fig/pair-rates/smooth-optim-anim-0.gif){.fragment .current-visible}

:::

::: {.notes}

- The big question is, "is it identifiable"

- Which in some sense reflects whether the loss surface is amenable to gradient descent

:::


## Fitting to empirical rates

::: {.r-stack}

![](fig/pair-optim/emp-rates-0.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-1.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-2.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-3.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-0.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-2.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-3.png){.fragment .current-visible}

:::

::: {.notes}

- This generalizes readily to more than two populations

- Using both first and second coalescences of trios (12 stats)

- In this case trio and pair rates look quite similar

- But provide more "observations" of the same pattern
  and are less sensitive to noise

- With more populations, using trio rates matters more as it generates
  non-redundant statistics

:::


## Fitting to inferred rates

::: {.r-stack}

![](fig/sim-tsinfer/mut-times-0.png){.fragment .current-visible width="50%" fig-align="center"}

![](fig/sim-tsinfer/mut-times-1.png){.fragment .current-visible width="50%" fig-align="center"}

:::

::: aside

[Kelleher et al (2019) *Nat Genet*, Wohns et al (2022) *Science*, Pope at al *in prep*]{style="font-size: 75%"}

:::


## Fitting to inferred rates

::: {.r-stack}

![](fig/sim-tsinfer/emp-pair-200-0.png){.fragment .current-visible}

![](fig/sim-tsinfer/emp-pair-200-1.png){.fragment .current-visible}

![](fig/sim-tsinfer/emp-pair-200-2.png){.fragment .current-visible}

![](fig/sim-tsinfer/emp-pair-200-3.png){.fragment .current-visible}

![](fig/sim-tsinfer/emp-pair-200-4.png){.fragment .current-visible}

![](fig/sim-tsinfer/emp-pair-200-5.png){.fragment .current-visible}

:::

::: {.notes}

- This machinery can easily be extended to more constrained settings, e.g. multiple rates per epoch, or parameterized functions

- Example is a little disingenuous, b/c noise in ARG inference will swamp out detail at that temporal scale

- For example, true vs inferred dates

- So as a litmus test i'm going to use a model on a log scale. The litmus test here is to infer the directionality of migration

:::


## Implementation details

::: {.fragment}

:::

Trio process also a CTMP 

## Implementation API

## WIP: fitting windowed rates

## WIP: fitting spatial rates

## Thank you!
