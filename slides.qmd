---
title: "Inferring complex demographic histories from coalescence time distributions"
author: "Nate Pope"
affiliation: "University of Oregon"
email: "natep@uoregon.edu"
venue: "PhyloSeminar"
date: "12 Nov 2024"
date-format: "MMM D, YYYY"
format: 
  revealjs:
    theme: white
    template-partials:
      - title-slide.html
---

## Demographic inference

::: {.r-stack}

![](fig/pop-model/pop-model-0.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=0}

![](fig/pop-model/pop-model-1.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=1}

![](fig/pop-model/pop-model-2.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=2}

![](fig/pop-model/pop-model-3.png){.fragment .current-visible width="50%" fig-align="center" fragment-index=3}

![](fig/pop-model/intgr-anim-0.gif){.fragment width="50%" fig-align="center" fragment-index=4}

:::

::: {.r-stack} 

::: {.fragment .current-visible fragment-index=0}
Given some population model, $\Theta$
:::

::: {.fragment .current-visible fragment-index=1}
$P(\mathrm{genealogy} \mid \Theta)$
:::

::: {.fragment .current-visible fragment-index=2}
Given some mutations, $m$
:::

::: {.fragment .current-visible fragment-index=3}
$p(m \mid \mathrm{genealogy})$
:::

::: {.fragment .current-visible fragment-index=4}
$p(m \mid \Theta) = \int p(m \mid \mathrm{genealogy}) dP(\mathrm{genealogy} \mid \Theta)$
:::

::: {.fragment .current-visible fragment-index=5}
Inference $\implies \mathrm{argmax}_{\Theta}~p(m \mid \Theta)$
:::

:::

::: {.notes}

- In a nutshell

:::


## Ancestral recombination graphs

::: {.r-stack}

![](fig/arg-3d/arg-3d-0.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-1.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-2.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-3.png){.fragment .current-visible}

![](fig/arg-3d/arg-3d-4.png){.fragment .current-visible}

:::

::: {.notes}

- Haplotypes along recombinant sequence of length L

- Single point on sequence, gives genealogy

- Recombination event results in prune/regraft of leaf

- Recombination event results in prune/regraft of root

- Crucial point is, nodes are shared across trees, e.g. ancestral haplotypes

- TODO: highlight edge

- TODO: haplotype view of ARG? text needed?

- Takeaway, space of ARGs is huge, integrating over it is hard

:::


## Inference at genomic scale

::: {.incremental}

- Reduce to haploid pair and integrate ARG (PSMC, etc.)

- Fit "marginal" statistics (SFS, LD, etc.)

- Jointly infer ARG and demography (MCMC)

- Condition on inferred ARG and ... ?

:::


## Coalescence time distributions

::: {.r-stack}

![](fig/tree-ecdf/tree-0.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-1.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-0.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-1.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-2.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-3.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-4.png){.fragment .current-visible}

![](fig/tree-ecdf/tree-ecdf-5.png){.fragment .current-visible}

:::


## Marginalizing over trees

::: {.r-stack}

![](fig/marg-ecdf/marg-ecdf-0.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-1.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-2.png){.fragment .current-visible}

![](fig/marg-ecdf/marg-ecdf-3.png){.fragment .current-visible}

:::

::: {.notes}

- Information is sparse in a single tree, especially deep in time, hence we use the ARG.

- The ECDF is a deterministic function of a tree. Integrating over trees gives the true CDF.

- The empirical version sums over trees, weighting by relative span.

- The weighted average converges to true CDF asymptotically

- TODO: node weights (probably?), convergence (?)

:::


## Efficient marginalization

::: {.r-stack}

![](fig/incr-algo/two-trees-0.png){.fragment .current-visible}

![](fig/incr-algo/two-trees-1.png){.fragment .current-visible}

![](fig/incr-algo/two-trees-2.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-0.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-1.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-2.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-3.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-4.png){.fragment .current-visible}

![](fig/incr-algo/left-tree-detail-5.png){.fragment .current-visible}

![](fig/incr-algo/right-tree-detail-0.png){.fragment .current-visible}

:::

::: {.notes}

- Need to leverage redundancy of trees for efficiency

- Work with the TreeSequence data format, tskit library

- Crucial ingredient are "edge differences" between adjacent trees

- e.g. a prune-regraft of a single branch leaves the bulk of the topology unchanged

- The idea is to propagate changes in node state up from the removed/added edge

- If there are multiple edges removed/added, need to be careful about order

- Complexity is O(edges log tips) to get node weights, querying ECDF is binary search O(log nodes)

- TODO: expository text, e.g. "Number of subtended samples S"

- TODO: plot showing scaling with number of tips

:::


## Duality of pair coalescence and Ne

::: {.r-stack}

![](fig/ne-duality/size-to-coal-0.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-1.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-2.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-3.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-4.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-5.png){.fragment .current-visible}

:::


## Duality of pair coalescence and Ne

::: {.fragment}
Let $c_{ab} = \frac{\int_a^b c(t) dt}{b - a}$ be average rate over interval,
:::

::: {.r-stack}

::: {.fragment .current-visible}
$$
  1 - \exp\{ -(b - a) c_{ab} \} = \frac{\mathrm{CDF}(b) - \mathrm{CDF}(a)}{1 - \mathrm{CDF}(a)} 
$$
:::

::: {.fragment .current-visible}
$$
  1 - \exp\{ -(b - a) c_{ab} \} \approx \frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)}
$$
:::

::: {.fragment .current-visible}
$$
  c_{ab} \approx (a - b)^{-1} \log \left\{ 1 - \frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)} \right\}
$$
:::

::: {.fragment}
$$
  c_{ab} \approx (b - a)^{-1} \left(\frac{\mathrm{ECDF}(b) - \mathrm{ECDF}(a)}{1 - \mathrm{ECDF}(a)} \right)
$$
:::

:::

::: {.fragment}
Note $c_{ab}^{-1}$ is harmonic average of $n(t)$ over interval
:::


## Duality of pair coalescence and Ne


::: {.r-stack}

![](fig/ne-duality/size-to-coal-6.png){.fragment .current-visible}

![](fig/ne-duality/size-to-coal-7.png){.fragment .current-visible}

:::

::: {.notes}

- Ne from coalescence rates from ARG isn't a new idea, cite Relate and maybe Yun's paper. Though maybe estimators are different

:::


## Pair coalescence and structure

TODO theory


## Pair coalescence and structure

::: {.r-stack}

![](fig/pair-rates/pair-rates-0.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-1.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-2.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-3.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-4.png){.fragment .current-visible}

![](fig/pair-rates/pair-rates-5.png){.fragment .current-visible}

![](fig/pair-rates/smooth-anim-0.gif){.fragment .current-visible}

:::

## Inverse problem

::: {.r-stack}

![](fig/pair-rates/pair-optim-0.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-1.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-2.png){.fragment .current-visible}

![](fig/pair-rates/pair-optim-3.png){.fragment .current-visible}

![](fig/pair-rates/smooth-optim-anim-0.gif){.fragment .current-visible}

:::

::: {.notes}

- The big question is, "is it identifiable"

- Which in some sense reflects whether the loss surface is amenable to gradient descent

:::


## Fitting to empirical rates

::: {.r-stack}

![](fig/pair-optim/emp-rates-0.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-1.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-2.png){.fragment .current-visible}

![](fig/pair-optim/emp-rates-3.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-0.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-1.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-2.png){.fragment .current-visible}

![](fig/pair-optim/emp-trio-rates-3.png){.fragment .current-visible}

:::

::: {.notes}

- This generalizes readily to more than two populations

- Using both first and second coalescences of trios (12 stats)

- In this case trio and pair rates look quite similar

- But provide more "observations" of the same pattern
  and are less sensitive to noise

- With more populations, using trio rates matters more as it generates
  non-redundant statistics

:::


## Fitting to inferred rates

::: {.notes}

- This machinery can easily be extended to more constrained settings, e.g. multiple rates per epoch, or parameterized functions

- Example is a little disingenuous, b/c noise in ARG inference will swamp out detail at that temporal scale

- For example, true vs inferred dates

- So as a litmus test i'm going to use a model on a log scale. The litmus test here is to infer the directionality of migration

- SINGER works great, blah blah

:::
